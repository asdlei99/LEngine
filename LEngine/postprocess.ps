////////////////////////////////////////////////////////////////////////////////
// Filename: postprocess.ps
////////////////////////////////////////////////////////////////////////////////

Texture2D screenTexture : register(t0);
Texture2D ssaoTexture : register(t1);
Texture2D bloomTexture : register(t2);
Texture2D lutTexture : register(t3);
Texture2D chromaticTexture : register(t4);
Texture2D whiteNoise : register(t5);
Texture2D whiteNoiseSmall : register(t6);
SamplerState SampleType : register(s0);

struct PixelInputType
{
    float4 position : SV_POSITION;
    float2 tex: TEXCOORD0;
};

cbuffer TextureBuffer
{
	float g_hasSSAO;
	float g_hasBloom;
	float g_hasLUT;
	float g_hasChromaticAberration;
	float g_hasGrain;

	float3 g_textureBufferPadding;
};

cbuffer ChromaticAberrationOffsets
{
	float g_rOffset;
	float g_gOffset;
	float g_bOffset;
	float g_chromaticIntensity;
};

cbuffer GrainSettings
{
	float g_grainSize;
	float g_grainIntensity;
	float g_grainWithColor;
	int g_grainType;
};

float luma(float3 color);
float luma(float4 color);
float4 CalculateGrain(float4 color, float2 tex);
////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 ColorPixelShader(PixelInputType input) : SV_TARGET
{
	float4 finalColor = screenTexture.Sample(SampleType, input.tex);

	//AMBIENT OCCLUSION
	[branch] if (g_hasSSAO > 0)
	{
		float ao = ssaoTexture.Sample(SampleType, input.tex);
		finalColor *= ao;
	}
	
	//LUT
	[branch] if (g_hasLUT > 0)
	{
		float4 lut = finalColor;
		float2 lutTex;

		lutTex.x = lut.r * 0.0625f; //RED
		lutTex.y = lut.g; //GREEN
		lutTex.x += (floor(lut.b * 16.0f)) * 0.0625f; //BLUE

		finalColor = lutTexture.Sample(SampleType, lutTex);
		//finalColor = float4(0.0f, saturate(lutTex.y), 0.0f, 1.0f);
	}

	//BLOOM
	float4 bloom = bloomTexture.Sample(SampleType, input.tex);
	finalColor += (bloom * g_hasBloom);
	//finalColor.xyz = pow(finalColor.xyz, float3(1.0f / 2.2f)); //gamma correction

	//CHROMATIC ABERRATION
	[branch] if (g_hasChromaticAberration > 0)
	{
		float rValue = screenTexture.Sample(SampleType, input.tex - g_rOffset).r;
		float gValue = screenTexture.Sample(SampleType, input.tex - g_gOffset).g;
		float bValue = screenTexture.Sample(SampleType, input.tex - g_bOffset).b;

		float4 chromatic = float4(rValue, gValue, bValue, 1.0f) - screenTexture.Sample(SampleType, input.tex);
		float intensity = chromaticTexture.Sample(SampleType, input.tex).r * g_chromaticIntensity;
		chromatic *= intensity;
		finalColor += chromatic;
		//finalColor = chromatic;
		//finalColor = float4(rValue, gValue, bValue, 1.0f);
	}

	//GRAIN
	[branch] if (g_hasGrain > 0)
	{
		finalColor = CalculateGrain(finalColor, input.tex);
	}
	return finalColor;
}

float luma(float3 color)
{
	return dot(color, float3(0.299, 0.587, 0.114));
}

float luma(float4 color) 
{
	return dot(color.rgb, float3(0.299, 0.587, 0.114));
}

float4 CalculateGrain(float4 color, float2 tex)
{
	float4 finalColor = color;

//Desaturation
	float luminance = luma(finalColor.rgb);
	float4 desaturated = float4(luminance, luminance, luminance, 1.0f);

//Calculate perlin noise
	float4 whiteNoiseSmallColor = whiteNoiseSmall.Sample(SampleType, tex * g_grainSize);

//Calculate white noise
	float4 whiteNoiseColor = whiteNoise.Sample(SampleType, tex * g_grainSize);

//Fix color
	//[branch] if (tempColor.r < 0.5f)
	{

	}

//Use pixels on correct hashes

	[branch] if (g_grainType == 0) //Small
	{
		float noiseColor = saturate(whiteNoiseSmallColor.r * whiteNoiseColor.r * g_grainIntensity);
		
		finalColor.r = lerp(finalColor.r, noiseColor, noiseColor);
		finalColor.g = lerp(finalColor.g, noiseColor, noiseColor);
		finalColor.b = lerp(finalColor.b, noiseColor, noiseColor);
	}
	else if (g_grainType == 1) //Unregular
	{
		float noiseColor = whiteNoiseColor.r;
		[branch] if (noiseColor < 0.44f + g_grainIntensity * 0.08f)
		{
			noiseColor = saturate(0.7f - g_grainIntensity * 0.5f);
			finalColor *= noiseColor;
		}
	}
	else if (g_grainType == 2) //Unregular white
	{
		float noiseColor = whiteNoiseColor.r;
		[branch] if (noiseColor < 0.44f + g_grainIntensity * 0.08f)
		{
			noiseColor *= (1.0f - (tex.x + tex.y) % noiseColor);
			finalColor.r = lerp(finalColor.r, noiseColor, noiseColor);
			finalColor.g = lerp(finalColor.g, noiseColor, noiseColor);
			finalColor.b = lerp(finalColor.b, noiseColor, noiseColor);
		}
	}

	return finalColor;
}